#' Summary of output parameters from the \code{PEG} and the \code{PTL} functions
#'
#' The function returns descriptive statistics (mean, median, se and 95 \% confidence intervals) for output parameters calculated by PEG or PTL functions. These parameters include : potential excess growth (PEG) or prescribed take level (PTL), sustainable harvest index (SHI), the maximum annual recruitment rate (Rmax) and the number of iterations for which the observed harvest level exceeds the theorical sustainable harvest (unsustain.harvest). Descriptive statistics are calculated from the \emph{n} simulations called within the \code{PEG} and \code{PTL} functions. When one or more parameters are fixed by the user, the corresponding value is reported for both the mean and the median, without any further measure of dispersion (i.e. se and 95 \% CI are set to zero). Statistics are reported in columns.
#'
#' @param data dataframe generated by the \code{PEG} function or the the \code{PTL} function detailing calculations for each of the n iterations. Other input will give an error.
#'
#' @return A dataframe containing the following statistics calculated from the n iterations:
#'
#' In columns :
#' \itemize{
#'   \item \code{SP} the species
#' }
#' In rows :
#' \itemize{
#'   \item \code{Fs} safety factor or \code{Fobj} objective factor
#'   \item \code{med.Rmax} median of the maximum annual recruitment rate
#'   \item \code{mean.Rmax} arithmetic mean of the maximum annual recruitment rate
#'   \item \code{percent2.5.Rmax} 2.5th pencentile of maximum annual recruitment rate
#'   \item \code{percent97.5.Rmax} 97.5th percentile of maximum annual recruitment rate
#'   \item \code{med.PEG} median of the potential excess growth
#'   \item \code{mean.PEG} arithmetic mean of the potential excess growth
#'   \item \code{percent2.5.PEG} 2.5th pencentile of the potential excess growth
#'   \item \code{percent97.5.PEG} 97.5th percentile of the potential excess growth
#'   \item \code{med.PTL} median of the maximum theoretical harvest
#'   \item \code{mean.PTL} arithmetic mean of the maximum theoretical harvest
#'   \item \code{percent2.5.PTL} 2.5th pencentile of the maximum theoretical harvest
#'   \item \code{percent97.5.PTL} 97.5th percentile of the maximum theoretical harvest
#'   \item \code{med.SHI} median of the sustainability harvest index
#'   \item \code{mean.SHI} arithmetic mean of the sustainability harvest index
#'   \item \code{percent2.5.SHI} 2.5th pencentile of the sustainability harvest index
#'   \item \code{percent97.5.SHI} 97.5th percentile of the sustainability harvest index
#'   \item \code{unsustain.harvest} frequency (1 = 100\%) of the n iterations for which observed harvest levels exceed the theoretical sustainable harvest levels
#' }
#' @export
#' @seealso \code{\link{PEG}}, \code{\link{PTL}}
#' @importFrom stats var median t.test quantile
#' @importFrom stringr str_sub
#'
#' @examples
#' df <- PEG(Nsim = 20, NSp = 2, living.rate = c("long", "short"),
#' surv.fixed = c(0.8, 0.65),
#' alpha.unif = TRUE, min.alpha = c(2, 1), max.alpha = c(3, 2),
#' pop.fixed = c(3605244, 55805898),
#' harvest.fixed = c(107802, 8447950),
#' Fs = c(0.1, 0.3, 0.5))
#'
#' output.summary(df)
#'
output.summary <- function(data){

  ## I. Error messages ----
  # Print error messages if the input datas are not correct
  if(is.null(data)){
    stop("'data' must be specified")
  }
  if (!is.data.frame(data)) {
    stop("'data' must be a dataframe")
  }
  if(!is.null(data$PEG) && !is.numeric(data$PEG)){
    stop("'PEG' column must be a numeric vector")
  }
  if(!is.null(data$PTL) && !is.numeric(data$PTL)){
    stop("'PTL' column must be a numeric vector")
  }
  if(is.null(data$SHI)){
    stop("'SHI' column does not exist")
  }
  if(!is.numeric(data$SHI)){
    stop("'SHI' column must be a numeric vector")
  }
  if(is.null(data$Rmax)){
    stop("'Rmax' column does not exist")
  }
  if(!is.numeric(data$Rmax)){
    stop("'Rmax' column must be a numeric vector")
  }



  ## II. Calculations ----
  # Standard error function ----
  se <- function(x) sqrt(var(x)/length(x))

  ## Step 1 : Create the end storage vectors to save results ----
  Output <- NULL



  ## Step 2 : Create the input data filter parameter for the loop of calculations bellow ----
  # This step is necessary to adapt the final data frame according to the PEG or PTL function used previously
  col <- which(colnames(data) == "Fs") # Search for a column named "Fs"
  if(length(col)> 0) {  # If TRUE, the PEG function was used previously
    data$code <- as.factor(paste0("SP", data$SP, " Fs ", data$Fs)) # Create a code which will be used for calculations in the step 3
  } else { # If the output comes from PTL function
    data$code <- as.factor(paste0("SP", data$SP, " Fobj ", data$Fobj)) # Create a code which will be used for calculations in the step 3
  }



  ## Step 3 : Loop of calulcations ----
  # This step allows to obtain the descriptive statistics of the parameters used as input data
  for (j in levels(data$code)){
    newdata <- subset(data, data$code == j) # Extracte the data frame for which the value of the 'code' column is equal to the level j



    ## Descriptive statistics of PEG ----
    col <- which(colnames(newdata) == "PEG") # Search for a column named "PEG" in the data frame named 'newdata'
    if(length(col)> 0){ # If TRUE, the PEG function was used previously
      mean.PEG <- round(mean(newdata$PEG)) # Mean rounded to the whole
      med.PEG <- round(median(newdata$PEG)) # Median rounded to the whole
      percent2.5.PEG <- round(quantile(newdata$PEG, probs=0.025))
      percent97.5.PEG <- round(quantile(newdata$PEG, probs=0.975))
    } # End of condition



    ## Descriptive statistics of PTL ----
    col <- which(colnames(newdata) == "PTL") # Search for a column named "PTL" in the data frame named 'newdata'
    if(length(col)> 0){ # If TRUE, the PEG function was used previously
      mean.PTL <- round(mean(newdata$PTL)) # Mean rounded to the whole
      med.PTL <- round(median(newdata$PTL)) # Median rounded to the whole
      percent2.5.PTL <- round(quantile(newdata$PTL, probs=0.025))
      percent97.5.PTL <- round(quantile(newdata$PTL, probs=0.975))
    } # End of condition



    ## Descriptive statistics of SHI ----
    mean.SHI <- round(mean(newdata$SHI), 3) # Mean rounded to the thousandth
    med.SHI <- round(median(newdata$SHI), 3) # Median rounded to the thousandth
    percent2.5.SHI <- round(quantile(newdata$SHI, probs=0.025), 3)
    percent97.5.SHI <- round(quantile(newdata$SHI, probs=0.975), 3)



    ## Descriptive statistics of Rmax ----
    mean.Rmax <- round(mean(newdata$Rmax), 3) # Mean rounded to the thousandth
    med.Rmax <- round(median(newdata$Rmax), 3) # Median rounded to the thousandth
    percent2.5.Rmax <- round(quantile(newdata$Rmax, probs=0.025), 3)
    percent97.5.Rmax <- round(quantile(newdata$Rmax, probs=0.975), 3)



    ## Calculations of Unsustainable harvest ----
    # Number of iterations for which the observed harvest exceeds the sustainable harvest index
    unsustainable.harvest <- ifelse(newdata$SHI > 1, 1, 0) # Assign 1 when observed harvest exceeds the sustainable harvest index, else Assign 0
    # Sum of iterations for which the observed harvest exceeds the sustainable harvest index
    sum.unsustainable.harvest <- sum(unsustainable.harvest) # Sum of 1
    # Frequency of iterations for which the observed harvest exceeds the sustainable harvest index
    unsustain.harvest.freq <- sum.unsustainable.harvest/nrow(newdata) # Sum of 1 divided by the total number of iterations



    ##  Step 4 : Output datas ----
    # Save temporary output from the temporary data frame named 'newdata'
    col <- which(colnames(newdata) == "Fs") # Search for a column named "Fs" in the data frame named 'newdata'
    if (length(col) > 0){ # If TRUE, the PEG function was used previously
      Fs <- unique(newdata$Fs) # Delete duplicates in the column 'Fs' in the data frame named 'newdata'
      OutputT <- data.frame( # Create a data frame named 'OutputT' containing descriptive statistics of Rmax, PEG, SHI and unsustain.harvest.freq
        code = newdata$code[1],
        Fs = Fs,
        med.Rmax = med.Rmax,
        mean.Rmax = mean.Rmax,
        percent2.5.Rmax = percent2.5.Rmax,
        percent97.5.Rmax = percent97.5.Rmax,
        med.PEG = med.PEG,
        mean.PEG = mean.PEG,
        percent2.5.PEG = percent2.5.PEG,
        percent97.5.PEG = percent97.5.PEG,
        med.SHI = med.SHI,
        mean.SHI = mean.SHI,
        percent2.5.SHI = percent2.5.SHI,
        percent97.5.SHI = percent97.5.SHI,
        unsustain.harvest = unsustain.harvest.freq
      )
    } else { # If there is no column named 'Fs' in the data frame named 'data' then there is a column named 'Fobj' exists
      Fobj <- unique(newdata$Fobj) # Delete duplicates in the column 'Fs' in the data frame named 'newdata'
      OutputT <- data.frame( # Create a data frame named 'OutputT' containing descriptive statistics of Rmax, PEG, SHI and unsustain.harvest.freq
        code = newdata$code[1],
        Fobj = Fobj,
        med.Rmax = med.Rmax,
        mean.Rmax = mean.Rmax,
        percent2.5.Rmax = percent2.5.Rmax,
        percent97.5.Rmax = percent97.5.Rmax,
        med.PTL = med.PTL,
        mean.PTL = mean.PTL,
        percent2.5.PTL = percent2.5.PTL,
        percent97.5.PTL = percent97.5.PTL,
        med.SHI = med.SHI,
        mean.SHI = mean.SHI,
        percent2.5.SHI = percent2.5.SHI,
        percent97.5.SHI = percent97.5.SHI,
        unsustain.harvest = unsustain.harvest.freq
      )
    } # End of condition



    ## Step 5 : Final ouptut ----
    Output <- rbind(Output, OutputT) # Combine by rows all temporary data frames for each level of j

  } # End of the loop j

  ## Step 6 : Transpose the dataframe ----
  code <- as.character(Output$code) # Converte the values of the column named 'code' as a character string
  #code <- str_sub(code, 1, 3)  # Extracte a character string which informs the number of the 'SP'
  code <- strsplit(code, split="_")[[1]][1] #to deal with Nspecies > 9
  Output <- t(Output) # Transpose of the data frame named 'Output'
  Output <- as.data.frame(Output)  # Converte the matrix named 'Output' as a data frame

  # Step 7 : Rename columns
  for(i in 1:ncol(Output)){
    name.col <- code[i]
    colnames(Output)[i] <- name.col
  }

  ## Step 8 : Delete the first row of the table which does not correspond to calculations ----
  Output <- Output[2:nrow(Output),, drop = F]

  ## Step 9 : Converte values of the data frame 'Output' as numeric vectors ----
  for(i in 1:ncol(Output)){
    Output[,i] <- as.numeric(as.character(Output[,i]))
  }

  print(Output)

} # End of the function
